### 单例类对OOP特性的支持不友好
1. 单例类对抽象，继承，多态都支持得不好
2. 使用中违背了基于接口而非实现的设计原则

### 单例类会隐藏类之间的依赖关系
1. 通过构造函数，参数传递等方式生命的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来
2. 但是单例类不需要显示创建，不需要依赖参数传递
3. 如果代码比较复杂，这种调用关系就会非常隐蔽

### 单例类对代码的扩展性不友好
1. 单例类只能有一个对象实例，如果未来某一天我们需要创建两个或多个实例，那就要对代码有比较大的改动
2. 譬如数据库连接池，可能慢慢发现针对慢查询需要建立一个单独的连接池
3. 如果一开始数据库连接池设计为单例那么修改就会比较复杂

### 单例类对代码的可测试性不友好
1. 单例类这种硬编码式的使用方式导致无法实现mock替换

### 单例不支持有参数的构造函数
1. 创建完实例后调用init函数传递参数
2. 将参数放到getInstance方法中
3. 将参数放到一个全局变量中，可以用过类中的静态常量定义，也可以从配置文件中加载得到

### 替代解决方案
可以通过静态方法来实现，不过其实比单例类更加不灵活，比如无法支持延迟加载等

```java
import java.util.concurrent.atomic.AtomicLong;

// 静态方法实现
public class IdGenerator {
    private static AtomicLong id = new AtomicLong(0);
    
    public static long getId() {
        return id.getAndIncrement();
    }
}

// 使用举例
long id = IdGenerator.getId();
```
